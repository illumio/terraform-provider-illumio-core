// Copyright 2021 Illumio, Inc. All Rights Reserved.

package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"

	"github.com/Jeffail/gabs/v2"
	"github.com/illumio/terraform-provider-illumio-core/client"
	"github.com/illumio/terraform-provider-illumio-core/models"
	"golang.org/x/time/rate"
)

const (
	// hrefs.csv is generated by terraform-illumio-provider
	// The file should contain 3 columns (orgID, resourceType, hrefOfResource) without headers
	filename = "hrefs.csv"
)

var (
	hrefSet        = map[string]bool{}
	pendingHrefSet = map[string]bool{}

	resourceTypeKeys = []string{
		"label_groups",
		"services",
		"rule_sets",
		"ip_lists",
		"virtual_services",
		"enforcement_boundaries",
	}
)

func main() {
	pceHost := os.Getenv("ILLUMIO_PCE_HOST")
	orgID, err := strconv.Atoi(os.Getenv("ILLUMIO_PCE_ORG_ID"))
	if err != nil {
		orgID = 1
	}
	apiKeyUsername := os.Getenv("ILLUMIO_API_KEY_USERNAME")
	apiKeySecret := os.Getenv("ILLUMIO_API_KEY_SECRET")
	if pceHost == "" || apiKeyUsername == "" || apiKeySecret == "" {
		log.Printf("[ERROR] Missing one of the required env. variable. ")
		log.Printf("[INFO] Please set env vars ILLUMIO_PCE_HOST, ILLUMIO_API_KEY_USERNAME, ILLUMIO_API_KEY_SECRET")
	}
	insecure := false
	if os.Getenv("ILLUMIO_ALLOW_INSECURE_TLS") == "yes" {
		insecure = true
	}

	illumioV2Client, err := client.NewV2(
		pceHost,
		orgID,
		apiKeyUsername,
		apiKeySecret,
		30,
		rate.NewLimiter(rate.Limit(float64(125)/float64(60)), 1), // limits API calls 125/min
		10,
		3,
		insecure,
		os.Getenv("ILLUMIO_CA_FILE"),
		os.Getenv("ILLUMIO_PROXY_URL"),
		os.Getenv("ILLUMIO_PROXY_CREDENTIALS"),
	)
	if err != nil {
		fmt.Printf("Error: %v", err)
		os.Exit(1)
	}

	hrefCount := 0 // Maintain count to check if api call is required or not
	cs := models.SecurityPolicyChangeSubset{}
	csp := &cs

	file, err := os.Open(filename)
	if err != nil {
		log.Printf("[ERROR] Error in opening file %s: %v", filename, err)
		os.Exit(1)
	}

	scanner := bufio.NewScanner(file)
	hrefs := []string{}
	rtypes := []string{}
	for scanner.Scan() {
		line := scanner.Text()
		line = strings.Trim(line, "\n ")
		// If empty, nothing to process
		if line == "" {
			continue
		}

		row := strings.Split(line, ",")
		rtype, href := row[0], row[1]
		if href == "" {
			continue
		}
		if _, ok := hrefSet[href]; ok {
			// Href already present in set, skipping
			continue
		}
		hrefs = append(hrefs, href)
		rtypes = append(rtypes, rtype)
		hrefSet[href] = true

	}
	_, cont, err := illumioV2Client.Get(fmt.Sprintf("/orgs/%d/sec_policy/pending", orgID), nil)
	if err != nil {
		log.Printf("[ERROR] Error in fetching pending security policy : %v", err)
		os.Exit(1)
	}
	// populates pending href set
	setPendingHref(cont)
	for index, href := range hrefs {
		if _, ok := pendingHrefSet[href]; !ok {
			log.Printf("[WARNING] Href not present in pending changes - skipping Href: %s", href)
			continue
		}
		rtype := rtypes[index]
		log.Printf("[DEBUG] ResourceType: %s, Href: %s", rtype, href)
		csp.AppendHref(rtype, href)
		hrefCount++
	}
	if hrefCount > 0 {
		secPolicy := &models.SecurityPolicy{
			UpdateDesc:   "Provisioned by terraform",
			ChangeSubset: cs,
		}
		_, data, err := illumioV2Client.Create(fmt.Sprintf("/orgs/%d/sec_policy", orgID), secPolicy)
		if err != nil {
			_ = file.Close()
			log.Printf("[DEBUG] Error while provisioning: %v", err)
			os.Exit(1)
		} else {
			_ = file.Close()
			log.Printf("[DEBUG] Response Data for provisioning: %v", data)
			// If Post call successful then, remove hrefs
			if e := os.Remove(filename); e != nil {
				log.Printf("[INFO] Error in removing file %s", filename)
			}
			os.Exit(0)
		}
	} else {
		log.Print("[INFO] No changes to provision")
		_ = file.Close()
		if e := os.Remove(filename); e != nil {
			log.Printf("[INFO] Error in removing file %s", filename)
		}
		os.Exit(0)
	}
	_ = file.Close()
}

// setPendingHref - Helper function to populate pending href set
func setPendingHref(data *gabs.Container) {
	for _, key := range resourceTypeKeys {
		for _, child := range data.S(key).Children() {
			pendingHrefSet[child.S("href").Data().(string)] = true
		}
	}
	if data.Exists("firewall_settings") {
		pendingHrefSet[data.S("firewall_settings", "href").Data().(string)] = true
	}
}
