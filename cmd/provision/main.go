// Copyright 2021 Illumio, Inc. All Rights Reserved.

package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"

	"github.com/Jeffail/gabs/v2"
	"github.com/illumio/terraform-provider-illumio-core/client"
	"github.com/illumio/terraform-provider-illumio-core/models"
	"golang.org/x/time/rate"
)

const (
	// hrefs.csv is generated by terraform-illumio-provider
	// The file should contain 2 columns (resource type, resource HREF) without headers
	filename = "hrefs.csv"
)

var (
	hrefSet        = map[string]bool{}
	pendingHrefSet = map[string]bool{}

	resourceTypeKeys = []string{
		"label_groups",
		"services",
		"rule_sets",
		"ip_lists",
		"virtual_services",
		"enforcement_boundaries",
	}
)

func main() {
	pceHost := os.Getenv("ILLUMIO_PCE_HOST")
	orgID, err := strconv.Atoi(os.Getenv("ILLUMIO_PCE_ORG_ID"))
	if err != nil {
		orgID = 1
	}
	apiKeyUsername := os.Getenv("ILLUMIO_API_KEY_USERNAME")
	apiKeySecret := os.Getenv("ILLUMIO_API_KEY_SECRET")
	if pceHost == "" || apiKeyUsername == "" || apiKeySecret == "" {
		log.Fatalf(`[ERROR] Missing a required environment variable.
Please set ILLUMIO_PCE_HOST, ILLUMIO_API_KEY_USERNAME, ILLUMIO_API_KEY_SECRET`)
	}
	insecure := false
	if os.Getenv("ILLUMIO_ALLOW_INSECURE_TLS") == "yes" {
		insecure = true
	}

	illumioV2Client, err := client.NewV2(
		pceHost,
		orgID,
		apiKeyUsername,
		apiKeySecret,
		30,
		rate.NewLimiter(rate.Limit(float64(125)/float64(60)), 1), // limits API calls 125/min
		10,
		3,
		insecure,
		os.Getenv("ILLUMIO_CA_FILE"),
		os.Getenv("ILLUMIO_PROXY_URL"),
		os.Getenv("ILLUMIO_PROXY_CREDENTIALS"),
	)
	if err != nil {
		log.Fatalf("[ERROR] %v", err)
	}

	changeSubset := new(models.SecurityPolicyChangeSubset)

	file, err := os.Open(filename)
	if err != nil {
		log.Fatalf("[ERROR] Error opening file %s: %v", filename, err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	hrefs := []string{}
	rtypes := []string{}
	for scanner.Scan() {
		line := scanner.Text()
		line = strings.Trim(line, "\n ")
		// if the line is empty, skip it
		if line == "" {
			continue
		}

		row := strings.Split(line, ",")
		rtype, href := row[0], row[1]
		if href == "" {
			continue
		}
		// if the HREF is already present in set, skip it
		if _, ok := hrefSet[href]; ok {
			continue
		}
		hrefs = append(hrefs, href)
		rtypes = append(rtypes, rtype)
		hrefSet[href] = true
	}

	_, cont, err := illumioV2Client.Get(fmt.Sprintf("/orgs/%d/sec_policy/pending", orgID), nil)
	if err != nil {
		log.Fatalf("[ERROR] Error fetching pending security policy: %v", err)
	}

	// populates pending href set
	setHrefs(cont)
	for index, href := range hrefs {
		if _, ok := pendingHrefSet[href]; !ok {
			log.Printf("[WARNING] HREF not present in pending changes - skipping Href: %s", href)
			continue
		}
		rtype := rtypes[index]
		log.Printf("[DEBUG] ResourceType: %s, HREF: %s", rtype, href)
		changeSubset.AppendHref(rtype, href)
	}

	if changeSubset.Size() > 0 {
		secPolicy := &models.SecurityPolicy{
			UpdateDesc:   "Provisioned by terraform",
			ChangeSubset: *changeSubset,
		}
		_, data, err := illumioV2Client.Create(fmt.Sprintf("/orgs/%d/sec_policy", orgID), secPolicy)
		if err != nil {
			log.Fatalf("[DEBUG] Error during provisioning: %v", err)
		}

		log.Printf("[DEBUG] Provisioning response: %v", data)
	} else {
		log.Print("[INFO] No changes to provision")
	}

	if e := os.Remove(filename); e != nil {
		log.Printf("[WARNING] Error removing file %s", filename)
	}
}

// setHrefs - Helper function to populate pending href set
func setHrefs(data *gabs.Container) {
	for _, key := range resourceTypeKeys {
		for _, child := range data.S(key).Children() {
			setPendingHref(child)
		}
	}
	if data.Exists("firewall_settings") {
		setPendingHref(data.S("firewall_settings"))
	}
}

func setPendingHref(data *gabs.Container) {
	if data.Exists("href") {
		href := data.S("href").Data()
		if href != nil {
			pendingHrefSet[href.(string)] = true
		}
	}
}
